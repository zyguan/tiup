package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"path"
	"strings"
	"sync"
	"time"

	"github.com/pingcap-incubator/tiup/pkg/meta"
	"github.com/pingcap/errors"
)

const (
	mtJSON  = "application/json"
	tiupVer = "v0.0.1"
)

type Entry struct {
	Path      string    `json:"path"`
	Name      string    `json:"name"`
	Type      string    `json:"type"`
	Extension string    `json:"extension"`
	Content   string    `json:"content"`
	Modified  time.Time `json:"modified"`
	Mode      int       `json:"mode"`
	Size      int       `json:"size"`
	IsDir     bool      `json:"isDir"`
}

type EntryList struct {
	Extension string    `json:"extension"`
	Name      string    `json:"name"`
	Path      string    `json:"path"`
	Type      string    `json:"type"`
	Modified  time.Time `json:"modified"`
	NumDirs   int       `json:"numDirs"`
	NumFiles  int       `json:"numFiles"`
	Size      int       `json:"size"`
	Mode      int       `json:"mode"`
	Items     []Entry   `json:"items"`
	IsDir     bool      `json:"isDir"`
	Sorting   struct {
		Asc bool   `json:"asc"`
		By  string `json:"by"`
	} `json:"sorting"`
}

type Client struct {
	*http.Client
	endpoint string
	user     string
	pass     string
	token    string
	lock     sync.RWMutex
}

func NewClient(endpoint string, user string, pass string) *Client {
	return &Client{
		Client:   http.DefaultClient,
		endpoint: endpoint,
		user:     user,
		pass:     pass,
	}
}

func (cli *Client) Raw(path string) (io.ReadCloser, error) {
	resp, err := http.Get(cli.mkURL("/raw"+path, map[string]string{"auth": cli.Token()}))
	if err != nil {
		return nil, err
	}
	if resp.StatusCode == http.StatusForbidden {
		if err = cli.auth(); err != nil {
			return nil, err
		}
		resp, err = http.Get(cli.mkURL("/raw"+path, map[string]string{"auth": cli.Token()}))
	}
	if err != nil {
		return nil, err
	}
	if resp.StatusCode != http.StatusOK {
		return nil, errors.New(resp.Status)
	}
	return resp.Body, nil
}

func (cli *Client) Get(path string) (*Entry, error) {
	var ent Entry
	if err := cli.load(path, &ent); err != nil {
		return nil, err
	}
	return &ent, nil
}

func (cli *Client) List(path string) (*EntryList, error) {
	var lst EntryList
	if err := cli.load(path, &lst); err != nil {
		return nil, err
	}
	return &lst, nil
}

func (cli *Client) Token() string {
	cli.lock.RLock()
	defer cli.lock.RUnlock()
	return cli.token
}

func (cli *Client) load(path string, res interface{}) error {
	err := cli.resource(path, res)
	if err != nil && strings.Contains(err.Error(), http.StatusText(http.StatusForbidden)) {
		if err = cli.auth(); err != nil {
			return err
		}
		return cli.resource(path, res)
	}
	return err
}

func (cli *Client) resource(path string, res interface{}) error {
	req, err := cli.mkReq(http.MethodGet, "/resources"+path, nil)
	if err != nil {
		return err
	}
	resp, err := cli.Do(req)
	if err != nil {
		return errors.Trace(err)
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return errors.New(resp.Status)
	}
	if err := json.NewDecoder(resp.Body).Decode(res); err != nil {
		return errors.Trace(err)
	}
	return nil
}

func (cli *Client) auth() error {
	r := new(bytes.Buffer)
	_ = json.NewEncoder(r).Encode(map[string]string{
		"username": cli.user, "password": cli.pass,
	})
	resp, err := cli.Post(cli.mkURL("/login", nil), mtJSON, r)
	if err != nil {
		return errors.Trace(err)
	}
	defer resp.Body.Close()
	if resp.StatusCode != http.StatusOK {
		return errors.New(resp.Status)
	}
	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return errors.Trace(err)
	}
	cli.lock.Lock()
	cli.token = string(body)
	cli.lock.Unlock()
	return nil
}

func (cli *Client) mkReq(method string, path string, body io.Reader) (*http.Request, error) {
	req, err := http.NewRequest(http.MethodGet, cli.mkURL(path, nil), nil)
	if err != nil {
		return nil, errors.Trace(err)
	}
	cli.lock.RLock()
	req.Header.Set("X-Auth", cli.token)
	cli.lock.RUnlock()
	return req, nil
}

func (cli *Client) mkURL(path string, params map[string]string) string {
	u := cli.endpoint + path
	if len(params) > 0 {
		vs := url.Values{}
		for k, v := range params {
			vs.Set(k, v)
		}
		u += "?" + vs.Encode()
	}
	return u
}

type CompMeta struct {
	Name      string   `json:"name"`
	Desc      string   `json:"desc"`
	Entry     string   `json:"entry"`
	Platforms []string `json:"platforms"`
}

type ProxyMeta struct {
	Redirect string     `json:"redirect"`
	Comps    []CompMeta `json:"components"`
}

func (pm *ProxyMeta) RenderComponentManifest() meta.ComponentManifest {
	m := meta.ComponentManifest{
		Description: "TiUP supported components list (generated by fbproxy)",
		Modified:    time.Now().Format(time.RFC3339),
		TiUPVersion: tiupVer,
	}
	m.Components = make([]meta.ComponentInfo, len(pm.Comps))
	for i, comp := range pm.Comps {
		m.Components[i] = meta.ComponentInfo{
			Name:      comp.Name,
			Desc:      comp.Desc,
			Platforms: comp.Platforms,
		}
	}
	return m
}

type Proxy struct {
	cli  *Client
	meta string
}

func NewProxy(cli *Client, meta string) *Proxy { return &Proxy{cli, meta} }

func (p *Proxy) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodGet {
		w.WriteHeader(http.StatusMethodNotAllowed)
		return
	}
	if r.URL.Path == "/" {
		w.WriteHeader(http.StatusBadRequest)
		return
	}
	pm, err := p.loadMeta()
	if err != nil {
		http.Error(w, "Load Proxy Meta: "+err.Error(), http.StatusInternalServerError)
		return
	}

	if r.URL.Path == "/tiup-manifest.index" {
		_ = json.NewEncoder(w).Encode(pm.RenderComponentManifest())
		return
	}

	for _, comp := range pm.Comps {
		if r.URL.Path == "/tiup-component-"+comp.Name+".index" {
			vers, err := p.renderVersionManifest(comp)
			if err != nil {
				http.Error(w, "Render Version Manifest: "+err.Error(), http.StatusInternalServerError)
				return
			}
			_ = json.NewEncoder(w).Encode(vers)
			return
		}
	}
	if len(pm.Redirect) > 0 {
		http.Redirect(w, r, fmt.Sprintf(pm.Redirect, r.URL.Path), http.StatusTemporaryRedirect)
		return
	}
	raw, err := p.cli.Raw(r.URL.Path)
	if err != nil {
		http.Error(w, "Forward Raw: "+err.Error(), http.StatusBadRequest)
	}
	defer raw.Close()
	io.Copy(w, raw)
}

func (p *Proxy) loadMeta() (*ProxyMeta, error) {
	ent, err := p.cli.Get(p.meta)
	if err != nil {
		return nil, err
	}
	var pm ProxyMeta
	if err := json.Unmarshal([]byte(ent.Content), &pm); err != nil {
		return nil, err
	}
	return &pm, nil
}

func (p *Proxy) renderVersionManifest(comp CompMeta) (*meta.VersionManifest, error) {
	m := meta.VersionManifest{
		Description: fmt.Sprintf("Versions of %s generated by fbproxy", comp.Name),
		Modified:    time.Now().Format(time.RFC3339),
	}
	if len(comp.Platforms) == 0 {
		return &m, nil
	}

	lst, err := p.cli.List(path.Dir(p.meta))
	if err != nil {
		return nil, err
	}
	idx := make(map[string]meta.VersionInfo)
	for _, it := range lst.Items {
		if !strings.HasPrefix(it.Name, comp.Name+"-") {
			continue
		}
		ver := strings.TrimPrefix(it.Name, comp.Name+"-")
		for _, platform := range comp.Platforms {
			p := strings.ReplaceAll(platform, "/", "-")
			if strings.HasSuffix(it.Name, "-"+p+".tar.gz") {
				ver = strings.TrimSuffix(ver, "-"+p+".tar.gz")
				c := idx[ver]
				c.Version = meta.Version(ver)
				c.Date = it.Modified.Format(time.RFC3339)
				c.Entry = comp.Entry
				c.Platforms = append(c.Platforms, platform)
				idx[ver] = c
				break
			}
		}
	}
	for _, vi := range idx {
		m.Versions = append(m.Versions, vi)
	}
	return &m, nil
}

func logHandler(h http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer func(t time.Time) {
			if x := recover(); x != nil {
				log.Printf("%s %s - %v !!! %+v", r.Method, r.URL.Path, time.Since(t), x)
			} else {
				log.Printf("%s %s - %v", r.Method, r.URL.Path, time.Since(t))
			}
		}(time.Now())
		h.ServeHTTP(w, r)
	})
}

func main() {
	var opts struct {
		Endpoint string
		Auth     string
		Meta     string
		Addr     string
	}
	flag.StringVar(&opts.Endpoint, "endpoint", "http://fileserver.pingcap.net:8080/api", "file browser api endpoint")
	flag.StringVar(&opts.Auth, "auth", "guest:guest", "auth info for file browser")
	flag.StringVar(&opts.Meta, "meta", "/pingcap/qa/archives/tiup-proxy.json", "path to proxy meta")
	flag.StringVar(&opts.Addr, "addr", ":8000", "addr to listen on")
	flag.Parse()

	userpass := strings.Split(opts.Auth, ":")
	if len(userpass) != 2 {
		log.Fatal("invalid auth format")
	}

	proxy := NewProxy(NewClient(opts.Endpoint, userpass[0], userpass[1]), opts.Meta)
	log.Print("listening on " + opts.Addr)
	log.Print(http.ListenAndServe(opts.Addr, logHandler(proxy)))
}
